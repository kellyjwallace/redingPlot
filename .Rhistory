lab <- letters[1:length(data)]
}
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
else{
print("not a list")
df <- data.frame(data,grouping)
}
df
number_groups<-nlevels(grouping)
if(missing(point_col)){
point_col=viridis(number_groups+2)[1:number_groups]
}
# to get nice x values for plotting, we'll use those generate by barplot()
x_values<-barplot(rep(1,number_groups),plot=F) %>% as.vector
# create the plot
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l",...)
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l")
axis(2,las=2)
# find range of x:
ifelse(length(data)==1,xRange <- 0.5,xRange <- range(x_values,na.rm=T)[2]-range(x_values,na.rm=T)[1])
# plot the mean as a line
for(i in 1:number_groups){
lines(x=c(x_values[i]-0.2,x_values[i]+0.2),y=c(rep(mean(df[df[,2] %in% lab[i],1]),2)),col=line_color,lwd=line_width)
}
# to plot the IQR:
if(IQR==TRUE){
p<-boxplot(data~grouping,plot=F)
for(i in 1:number_groups){
lines(x=c(x_values[i],x_values[i]),y=c(p$stats[2,i],p$stats[4,i]),lwd=2,col=addAlpha(line_color))
}
}
p
IQR=TRUE
if(IQR==TRUE){
p<-boxplot(data~grouping,plot=F)
for(i in 1:number_groups){
lines(x=c(x_values[i],x_values[i]),y=c(p$stats[2,i],p$stats[4,i]),lwd=2,col=addAlpha(line_color))
}
}
p
if(length(point_col==1)){
point_col = rep(point_col,number_groups)
}
# draw data points
if(jitter==T){
for(i in 1:number_groups){
points(x=rep(x_values[i], nrow(df[df[,2] %in% lab[i],])) %>% jitter(amount = 0.05), y=df[df[,2] %in% lab[i],1], pch=16, col=point_col[i], cex=point_size)
}
}
else{
for(i in 1:number_groups){
points(x=rep(x_values[i],length(df[df[,2] %in% lab[i],1])), y=df[df[,2] %in% lab[i],1], pch=16,col=point_col[i],cex=point_size)
}
}
# for rug plotting:
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
ruf=TRUE
rug=TRUE
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
if(median==T){
points(x=x_values,y=by(df[,1], df[,2], median) %>% as.vector, pch=5, col=line_color, cex=1.5, lwd=3)
}
median=T
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
if(median==T){
points(x=x_values,y=by(df[,1], df[,2], median) %>% as.vector, pch=5, col="black", cex=1.5, lwd=3)
}
by(df[,1], df[,2], median)
?by
by(df[,1], df[,2] %>% factor, median)
/median
?median
by(df[,1], df[,2] %>% factor, mean)
by(df[,1], df[,2] %>% factor, median)
by(df[,1], df[,2],sd)
by(df[,1], df[,2],sd) %>% as.vector
by(df[,1], df[,2], median) %>% as.vector
by(df[,1], df[,2], median,) %>% as.vector
require(redingPlot)
ruby <-rgb(202/255,53/255,7/255,1)
slate <- rgb(137/255,157/255,164/255,1)
mint <- rgb(73/255,191/255,150/255,1)
golden <- rgb(218/255,165/255,32/255,1)
orange <- rgb(227/255,121/255,46/255,1)
sky <- rgb(95/255,188/255,212/255,1)
cols<-c(ruby,mint,golden,slate,orange,sky)
x<-list(rnorm(50,50,5),rnorm(30,40,6),rnorm(10,60,2),rnorm(60,50,10),rnorm(30,39,4))
simple<-function(data,grouping,lab=NA,point_size=1.2,line_color="red",line_width=3.0,jitter=T,point_col=NA,median=FALSE,rug=TRUE,sample_size=T,...){
# if response is missing, assume data is a list
if(missing(grouping)){
if(is.list(data)==FALSE){
stop("enter your data either as a list or as a response variable and factor within a dataframe")
}
}
if(is.list(data)){
print("list")
# if its a list, turn it into a dataframe
# this is a stupid way to make this data frame, but whatever:
if(missing(lab)){
lab <- letters[1:length(data)]
}
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
else{
print("not a list")
df <- data.frame(data,grouping)
}
#######################
number_groups<-nlevels(grouping)
if(missing(point_col)){
point_col=viridis(number_groups+2)[1:number_groups]
}
# to get nice x values for plotting, we'll use those generate by barplot()
x_values<-barplot(rep(1,number_groups),plot=F) %>% as.vector
# create the plot
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l",...)
# create y axis with the numbers the correct direction
axis(2,las=2)
# find range of x:
ifelse(length(data)==1,xRange <- 0.5,xRange <- range(x_values,na.rm=T)[2]-range(x_values,na.rm=T)[1])
# plot the mean as a line
for(i in 1:number_groups){
lines(x=c(x_values[i]-0.2,x_values[i]+0.2),y=c(rep(mean(df[df[,2] %in% lab[i],1]),2)),col=line_color,lwd=line_width)
}
# create x axis
axis(side=1,at=x_values,labels=lab)
# make point_col length equal to number of groups
if(length(point_col==1)){
point_col = rep(point_col,number_groups)
}
# draw data points
if(jitter==T){
for(i in 1:number_groups){
points(x=rep(x_values[i], nrow(df[df[,2] %in% lab[i],])) %>% jitter(amount = 0.05), y=df[df[,2] %in% lab[i],1], pch=16, col=point_col[i], cex=point_size)
}
}
else{
for(i in 1:number_groups){
points(x=rep(x_values[i],length(df[df[,2] %in% lab[i],1])), y=df[df[,2] %in% lab[i],1], pch=16,col=point_col[i],cex=point_size)
}
}
# for rug plotting:
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
# for plotting the median as a diamond:
if(median==T){
points(x=x_values,y=by(df[,1], df[,2], median) %>% as.vector, pch=5, col=line_color, cex=1.5, lwd=3)
}
# for plotting sample size below each group
if(sample_size==TRUE){
for(i in 1:number_groups){
text(x_values[i],par("usr")[3]*1.03,paste("n = ", length(df[df[,2] %in% lab[i],1]),sep=""),col="grey20",pos=3)
}
}
}
simple(x,point_col=viridis(5),line_color="black",median=T,main="simple() dressed up")
simple(list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
data=x
if(is.list(data)){
print("list")
# if its a list, turn it into a dataframe
# this is a stupid way to make this data frame, but whatever:
if(missing(lab)){
lab <- letters[1:length(data)]
}
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
if(missing(lab)){
lab <- letters[1:length(data)]
}
lab <- letters[1:length(data)]
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
number_groups<-nlevels(grouping)
if(missing(point_col)){
point_col=viridis(number_groups+2)[1:number_groups]
}
# to get nice x values for plotting, we'll use those generate by barplot()
x_values<-barplot(rep(1,number_groups),plot=F) %>% as.vector
# create the plot
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l",...)
# create y axis with the numbers the correct direction
axis(2,las=2)
# find range of x:
ifelse(length(data)==1,xRange <- 0.5,xRange <- range(x_values,na.rm=T)[2]-range(x_values,na.rm=T)[1])
# plot the mean as a line
for(i in 1:number_groups){
lines(x=c(x_values[i]-0.2,x_values[i]+0.2),y=c(rep(mean(df[df[,2] %in% lab[i],1]),2)),col=line_color,lwd=line_width)
}
# create x axis
axis(side=1,at=x_values,labels=lab)
# make point_col length equal to number of groups
if(length(point_col==1)){
point_col = rep(point_col,number_groups)
}
# draw data points
if(jitter==T){
for(i in 1:number_groups){
points(x=rep(x_values[i], nrow(df[df[,2] %in% lab[i],])) %>% jitter(amount = 0.05), y=df[df[,2] %in% lab[i],1], pch=16, col=point_col[i], cex=point_size)
}
}
else{
for(i in 1:number_groups){
points(x=rep(x_values[i],length(df[df[,2] %in% lab[i],1])), y=df[df[,2] %in% lab[i],1], pch=16,col=point_col[i],cex=point_size)
}
}
# for rug plotting:
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
# for plotting the median as a diamond:
if(median==T){
points(x=x_values,y=by(df[,1], df[,2], median) %>% as.vector, pch=5, col=line_color, cex=1.5, lwd=3)
}
median=T
df
by(df[,1], df[,2], median)
?by
by(df[,1], df[,2], meeam)
by(df[,1], df[,2], meam)
by(df[,1], df[,2], mean)
points(x=x_values,y=by(df[,1], df[,2], mean) %>% as.vector, pch=5, col=line_color, cex=1.5, lwd=3)
points(x=x_values,y=by(df[,1], df[,2], mean) %>% as.vector)
if(median==T){
for(i 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col=line_color, cex=1.5, lwd=3)
}
}
if(median==T){
for(i 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col=line_color, cex=1.5, lwd=3)
}
}
if(median==T){
for(i in 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col=line_color, cex=1.5, lwd=3)
}
}
if(median==T){
for(i in 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col="red", cex=1.5, lwd=3)
}
}
if(sample_size==TRUE){
for(i in 1:number_groups){
text(x_values[i],par("usr")[3]*1.03,paste("n = ", length(df[df[,2] %in% lab[i],1]),sep=""),col="grey20",pos=3)
}
}
}
sample_size=T
if(sample_size==TRUE){
for(i in 1:number_groups){
text(x_values[i],par("usr")[3]*1.03,paste("n = ", length(df[df[,2] %in% lab[i],1]),sep=""),col="grey20",pos=3)
}
}
}
simple<-function(data,grouping,lab=NA,point_size=1.2,line_color="red",line_width=3.0,jitter=T,point_col=NA,median=FALSE,rug=TRUE,sample_size=T,...){
# if response is missing, assume data is a list
if(missing(grouping)){
if(is.list(data)==FALSE){
stop("enter your data either as a list or as a response variable and factor within a dataframe")
}
}
if(is.list(data)){
print("list")
# if its a list, turn it into a dataframe
# this is a stupid way to make this data frame, but whatever:
if(missing(lab)){
lab <- letters[1:length(data)]
}
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
else{
print("not a list")
df <- data.frame(data,grouping)
}
#######################
number_groups<-nlevels(grouping)
if(missing(point_col)){
point_col=viridis(number_groups+2)[1:number_groups]
}
# to get nice x values for plotting, we'll use those generate by barplot()
x_values<-barplot(rep(1,number_groups),plot=F) %>% as.vector
# create the plot
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l",...)
# create y axis with the numbers the correct direction
axis(2,las=2)
# find range of x:
ifelse(length(data)==1,xRange <- 0.5,xRange <- range(x_values,na.rm=T)[2]-range(x_values,na.rm=T)[1])
# plot the mean as a line
for(i in 1:number_groups){
lines(x=c(x_values[i]-0.2,x_values[i]+0.2),y=c(rep(mean(df[df[,2] %in% lab[i],1]),2)),col=line_color,lwd=line_width)
}
# create x axis
axis(side=1,at=x_values,labels=lab)
# make point_col length equal to number of groups
if(length(point_col==1)){
point_col = rep(point_col,number_groups)
}
# draw data points
if(jitter==T){
for(i in 1:number_groups){
points(x=rep(x_values[i], nrow(df[df[,2] %in% lab[i],])) %>% jitter(amount = 0.05), y=df[df[,2] %in% lab[i],1], pch=16, col=point_col[i], cex=point_size)
}
}
else{
for(i in 1:number_groups){
points(x=rep(x_values[i],length(df[df[,2] %in% lab[i],1])), y=df[df[,2] %in% lab[i],1], pch=16,col=point_col[i],cex=point_size)
}
}
# for rug plotting:
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
# for plotting the median as a diamond:
if(median==T){
for(i in 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col=line_color, cex=1.5, lwd=3)
}
}
# for plotting sample size below each group
if(sample_size==TRUE){
for(i in 1:number_groups){
text(x_values[i],par("usr")[3]*1.03,paste("n = ", length(df[df[,2] %in% lab[i],1]),sep=""),col="grey20",pos=3)
}
}
}
simple(list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
x<-list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15));lab=c("normal","chi-squared","exponetial","uniform")
print("list")
# if its a list, turn it into a dataframe
# this is a stupid way to make this data frame, but whatever:
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
labels <- c()
sizes <- sapply(x,length)
x
sizes
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
1:length(data)
x<-data<-list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15));lab=c("normal","chi-squared","exponetial","uniform")
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
df
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
rm(list=ls())
simple<-function(data,grouping,lab=NA,point_size=1.2,line_color="red",line_width=3.0,jitter=T,point_col=NA,median=FALSE,rug=TRUE,sample_size=T,...){
# if response is missing, assume data is a list
if(missing(grouping)){
if(is.list(data)==FALSE){
stop("enter your data either as a list or as a response variable and factor within a dataframe")
}
}
if(is.list(data)){
print("list")
# if its a list, turn it into a dataframe
# this is a stupid way to make this data frame, but whatever:
if(missing(lab)){
lab <- letters[1:length(data)]
}
labels <- c()
sizes <- sapply(x,length)
for(i in 1:length(data)){
labels <- c(labels,rep(lab[i], sizes[i]))
}
df <- data.frame(matrix(unlist(data), nrow=length(unlist(data)), byrow=T),labels)
data <- df[,1]
grouping <- df[,2] %>% factor
}
else{
print("not a list")
df <- data.frame(data,grouping)
}
#######################
number_groups<-nlevels(grouping)
if(missing(point_col)){
point_col=viridis(number_groups+2)[1:number_groups]
}
# to get nice x values for plotting, we'll use those generate by barplot()
x_values<-barplot(rep(1,number_groups),plot=F) %>% as.vector
# create the plot
plot(c(x_values[1]*0.4,x_values[length(x_values)]*1.2), xlim=c(x_values[1]*0.4,x_values[length(x_values)]*1.2),ylim=c(min(data,na.rm=T)*0.95, max(data,na.rm=T)*1.05),type="n",xaxt="n",yaxt="n",bty="l",...)
# create y axis with the numbers the correct direction
axis(2,las=2)
# find range of x:
ifelse(length(data)==1,xRange <- 0.5,xRange <- range(x_values,na.rm=T)[2]-range(x_values,na.rm=T)[1])
# plot the mean as a line
for(i in 1:number_groups){
lines(x=c(x_values[i]-0.2,x_values[i]+0.2),y=c(rep(mean(df[df[,2] %in% lab[i],1]),2)),col=line_color,lwd=line_width)
}
# create x axis
axis(side=1,at=x_values,labels=lab)
# make point_col length equal to number of groups
if(length(point_col==1)){
point_col = rep(point_col,number_groups)
}
# draw data points
if(jitter==T){
for(i in 1:number_groups){
points(x=rep(x_values[i], nrow(df[df[,2] %in% lab[i],])) %>% jitter(amount = 0.05), y=df[df[,2] %in% lab[i],1], pch=16, col=point_col[i], cex=point_size)
}
}
else{
for(i in 1:number_groups){
points(x=rep(x_values[i],length(df[df[,2] %in% lab[i],1])), y=df[df[,2] %in% lab[i],1], pch=16,col=point_col[i],cex=point_size)
}
}
# for rug plotting:
if(rug==T){
for(i in 1:number_groups){
rug(df[df[,2] %in% lab[i],1],side=4,col=addAlpha(point_col[i],0.4),lwd=4)
}
}
# for plotting the median as a diamond:
if(median==T){
for(i in 1:number_groups){
points(x=x_values[i],y=median(df[df[,2] %in% lab[i],1]), pch=5, col=line_color, cex=1.5, lwd=3)
}
}
# for plotting sample size below each group
if(sample_size==TRUE){
for(i in 1:number_groups){
text(x_values[i],par("usr")[3]*1.03,paste("n = ", length(df[df[,2] %in% lab[i],1]),sep=""),col="grey20",pos=3)
}
}
}
simple(list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
simple(list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
simple(data=list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
simple(data=list(rnorm(24,10,2),rchisq(20,5),rexp(40,1/5),runif(40,5,15)),lab=c("normal","chi-squared","exponetial","uniform"),point_col=c(ruby,mint,slate,"goldenrod"),line_color="black",median=T)
require(redingply)
require(redingPlot)
?simple
?beeStrip
x <- list(rnorm(40,40,5),rnorm(20,35,2),rnorm(25,41,2))
x <- list(rnorm(40,40,5),rnorm(20,35,2),rnorm(25,41,2)) ; simple(x,main="simple() defaults") # using the defaults
library(devtools)
library(roxygen2)
setwd("~/Documents/redingPlot/")
document()
install_github("lukereding/redingPlot")
